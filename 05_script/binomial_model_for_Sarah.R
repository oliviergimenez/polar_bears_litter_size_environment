#==============================================================================#
#                                                                              #
#                          Binomial model for Sarah                           #
#                                                                              #
#==============================================================================#


library(tidyverse)
library(mlogit)
library(viridis)
library(ggmcmc)
library(cowplot)
library(nimble)
Sys.setenv(LANG = "en")

# READY VARIABLES ===========================================================
# CR data
CR_data <- read_csv("06_processed_data/CR_data/CR_f_with_cubs_clean.csv")

# Sea ice data
sea_ice_data <- read_csv("06_processed_data/sea_ice_data/retreat_advance_ice_free_days_D.csv")
sea_ice_data <- data.frame(sea_ice_data,
                           ice_free_days_previous = c(NA, sea_ice_data$ice_free_days[-nrow(sea_ice_data)]),
                           ice_free_days_2y_prior = c(NA, NA, sea_ice_data$ice_free_days[-c(nrow(sea_ice_data),
                                                                                            nrow(sea_ice_data) - 1)]))

data_model <- CR_data %>%
  mutate(success = ifelse(cub_number == 1, 0, 1)) %>%
  group_by(year) %>%
  summarise(successes = sum(success)) %>%
  left_join(x = .,
            y = sea_ice_data,
            by = "year")



# Response variable
y <- CR_data %>%
  pull(successes)
summary(y)

# Number of litters per year
n <- CR_data %>%
  count(year) %>%
  pull(n)


# Renumérotation des années
{year <- data_model$year
  year <- factor(year) # laisse tomber les modalites inutiles 
  year2 <- NULL
  for (i in 1:length(year)){
    year2 <- c(year2, which(year[i] == levels(year)))
  }
  year <- factor(year2)
  nbyear <- length(levels(year))
  year
  }


dat <- list(y = as.numeric(y))
# Load the JAGS models + the ancillary functions
source("05_script/models/functions_for_models_Nimble.R")



# RUN MODELS ===================================================================

# A. Null model ================================================================

model_0.0.0.0_binomial <- nimbleCode({
  for(i in 1:N) {
    y[i] ~ dbin(p[i], n[i])
    logit(p[i]) <- b0
  }
  b0 ~ dnorm(0.00000E+00, sd = 1.5)
})

# Bernoulli
# model_0.0.0.0_binomial <- nimbleCode({
#   for(i in 1:N) {
#     y[i] ~ dbin(p[i], 1)
#     logit(p[i]) <- b0
#   }
#   b0 ~ dnorm(0.00000E+00, sd = 1.5)
# })

# ~~~ a. Run the model ---------------------------------------------------------

my.constants <- list(N = length(y), # nb of females captured
                     J = length(levels(y)),
                     year = as.numeric(year),
                     nbyear = nbyear,
                     n = n) 

params <- c("b0")

# Find initial value for the intercept
binomial.frequ <- glm(y ~ 1, 
                      family = "binomial", 
                      data = data.frame(y = as.factor(y_bis)))

coefs <- as.vector(summary(binomial.frequ)$coefficients[1])
inits_null <- function() list(b0 = coefs + round(runif(n = 1, -1, 1))/10)


start <- Sys.time()
fit_0.0.0.0_binomial <- nimbleMCMC(code = model_0.0.0.0_binomial,     # model code  
                          data = dat,                                   
                          constants = my.constants,        
                          inits = inits_null,          
                          monitors = params,   # parameters to monitor
                          niter = 20000,                  # nb iterations
                          nburnin = 5000,              # length of the burn-in
                          nchains = 2,
                          summary = TRUE,
                          WAIC = TRUE)
end <- Sys.time()
end - start

fit_0.0.0.0_binomial$WAIC

save(list = fit_0.0.0.0_binomial, 
     file = "07_results/model_0.0.0.0_binomial.RData")



# ~~~ b. Check convergence -----------------------------------------------------
nimble_output <- fit_0.0.0.0_binomial

# Process Nimble output into dataframe
chain1 <- data.frame(nimble_output[["samples"]][["chain1"]]) %>%
  dplyr::select(params[-length(params)]) %>%
  mutate(chain = "1",
         iteration = seq(1, dim(nimble_output[["samples"]][["chain1"]])[1], by = 1))
chain2 <- data.frame(nimble_output[["samples"]][["chain2"]]) %>%
  dplyr::select(params[-length(params)]) %>%
  mutate(chain = "2",
         iteration = seq(1, dim(nimble_output[["samples"]][["chain2"]])[1], by = 1))
chains <- rbind(chain1, chain2) 

chains_l <- pivot_longer(chains, cols = params, names_to = "parameter") 

param.mean <- chains_l %>%
  group_by(parameter, chain) %>%
  summarize(m = mean(value))

param.running.mean <- chains_l %>%
  arrange(parameter, iteration) %>%
  group_by(parameter, chain) %>%
  mutate(rm = cumsum(value)/iteration)

trace.plots <- ggplot(data = chains_l, 
                      aes(x = iteration, y = value, color = chain)) +
  geom_line() +
  labs(y = "trace") +
  theme(legend.position = "none") +
  facet_wrap( ~ parameter,
              scales = "free",
              ncol = 1)

density.plots <- ggplot(data = chains_l, 
                        aes(x = value, color = chain, fill = chain)) +
  geom_density(alpha = 0.25) +
  labs(x = "density") +
  theme(legend.position = "none") +
  facet_wrap( ~ parameter,
              scales = "free_y",
              ncol = 1)

running.mean.plot <- ggplot(param.running.mean, 
                            aes(x = iteration, y = rm, color = chain)) + 
  geom_line() + 
  geom_hline(aes(yintercept = m), param.mean,
             colour = "black", alpha = 0.5) + 
  ylab("running Mean") +
  facet_grid(parameter ~ chain, scales = "free")

# Plot all the plots together
diagnostic_plot <- plot_grid(trace.plots,
                             density.plots, 
                             running.mean.plot,
                             ncol = 3, nrow = 1)
diagnostic_plot




# B. Model with only ice-free days (binomial) ==================================

model_1.1.2_D_binomial <- nimbleCode({
  for(i in 1:N) {
    y[i] ~ dbin(p[i], n[i])
    logit(p[i]) <- b0 + b1 * ice_free_days_previous_s[i] + eps1[year[i]]
  }
  for (i in 1:nbyear) {
    eps1[i] ~ dnorm(0, sd = sigma1)
  }
  sigma1 ~ dunif(0.00000E+00, 10)
  b0 ~ dnorm(0.00000E+00, sd = 10)
  b1 ~ dnorm(0.00000E+00, sd = 10)
})


# ~~~ a. Run the model ---------------------------------------------------------

# Predictor
var <- data_model$ice_free_days_previous
var_scaled <- (var - mean(var))/sd(var) 
var_short_name <- "ice_free_days_previous_s"
var_full_name <- "Ice-free days in previous year"

# Are females without cubs taken into account ?

my.constants <- list(N = length(y_bis),            # nb of females captured
                     J = length(levels(y_bis)),
                     year = as.numeric(year),
                     nbyear = nbyear,
                     n = n,                    # nb of females captured the same year
                     as.numeric(var_scaled)) 
names(my.constants)[6] <- var_short_name


# Define the parameters to estimate
params <- c("b0", "b1", "sigma1", "eps1")
temp.data <- data.frame(y = y, 
                        var_scaled = var_scaled)
mylogit <- glm(as.factor(y) ~ var_scaled, data = temp.data, family = "binomial")

inits <- function() list(b0 = mylogit$coefficients[1] + round(runif(n = 1, -1, 1))/10, 
                         b1 = mylogit$coefficients[2] + round(runif(n = 1, -1, 1))/10,
                         sigma1 = runif(1))



# Run the model
start <- Sys.time()

fit_1.1.2_D_binomial <- nimbleMCMC(code = model_1.1.2_D_binomial,     # model code  
                                   data = dat,                                   
                                   constants = my.constants,        
                                   inits = inits,          
                                   monitors = params,   # parameters to monitor
                                   thin = 10,
                                   niter = 15000,                  # nb iterations
                                   nburnin = 5000,              # length of the burn-in
                                   nchains = 2,
                                   summary = TRUE,
                                   WAIC = TRUE)
end <- Sys.time()
end - start


fit_1.1.2_D_binomial$WAIC

save(list = fit_1.1.2_D_binomial, 
     file = "07_results/model_1.1.2_D_binomial.RData")


# ~~~ b. Check convergence -----------------------------------------------------

nimble_output <- fit_1.1.2_D_binomial

# Process Nimble output into dataframe
chain1 <- data.frame(nimble_output[["samples"]][["chain1"]]) %>%
  dplyr::select(params[-length(params)]) %>%
  mutate(chain = "1",
         iteration = seq(1, dim(nimble_output[["samples"]][["chain1"]])[1], by = 1))
chain2 <- data.frame(nimble_output[["samples"]][["chain2"]]) %>%
  dplyr::select(params[-length(params)]) %>%
  mutate(chain = "2",
         iteration = seq(1, dim(nimble_output[["samples"]][["chain2"]])[1], by = 1))
chains <- rbind(chain1, chain2) 

chains_l <- pivot_longer(chains, cols = params[-length(params)], names_to = "parameter") 

param.mean <- chains_l %>%
  group_by(parameter, chain) %>%
  summarize(m = mean(value))

param.running.mean <- chains_l %>%
  arrange(parameter, iteration) %>%
  group_by(parameter, chain) %>%
  mutate(rm = cumsum(value)/iteration)

trace.plots <- ggplot(data = chains_l, 
                      aes(x = iteration, y = value, color = chain)) +
  geom_line() +
  labs(y = "trace") +
  theme(legend.position = "none") +
  facet_wrap( ~ parameter,
              scales = "free",
              ncol = 1)

density.plots <- ggplot(data = chains_l, 
                        aes(x = value, color = chain, fill = chain)) +
  geom_density(alpha = 0.25) +
  labs(x = "density") +
  theme(legend.position = "none") +
  facet_wrap( ~ parameter,
              scales = "free_y",
              ncol = 1)

running.mean.plot <- ggplot(param.running.mean, 
                            aes(x = iteration, y = rm, color = chain)) + 
  geom_line() + 
  geom_hline(aes(yintercept = m), param.mean,
             colour = "black", alpha = 0.5) + 
  ylab("running Mean") +
  facet_grid(parameter ~ chain, scales = "free")

# Plot all the plots together
diagnostic_plot <- plot_grid(trace.plots,
                             density.plots, 
                             running.mean.plot,
                             ncol = 3, nrow = 1)
diagnostic_plot


# ~~~ c. Plot ------------------------------------------------------------------

res <- rbind(fit_1.1.2_D_binomial$samples$chain1,
              fit_1.1.2_D_binomial$samples$chain2)

# Create grid of x values
range <- range(var_scaled)

lengthgrid <- 100
grid_scaled <- seq(from = range[1] - 0.1*(range[2] - range[1]), 
                   to = range[2] + 0.1*(range[2] - range[1]), 
                   length = lengthgrid)

grid <- grid_scaled * sd(var) + mean(var)

p2_3cub <- matrix(data = NA, 
                           nrow = dim(res)[1], 
                           ncol = lengthgrid)

for (i in 1:lengthgrid) {
  for (j in 1:dim(res)[1]) {
    # p2_3cub[j, i] <- plogis(res[j, 1] + res[j, 2] * grid_scaled[i])	
    p2_3cub[j, i] <- exp(res[j, 1] + res[j, 2] * grid_scaled[i])/(1 + exp(res[j, 1] + res[j, 2] * grid_scaled[i]))
  }
}

?plogis
df.for.plot <- data.frame(var = grid,
                          mean_p_2_3_cub = apply(p2_3cub, 2, mean),
                          ci_p_2_3_cub_2.5 = apply(p2_3cub, 2, quantile, probs = 0.025),
                          ci_p_2_3_cub_97.5 = apply(p2_3cub, 2, quantile, probs = 0.975)) %>%
  pivot_longer(cols = c("mean_p_2_3_cub", "ci_p_2_3_cub_2.5", "ci_p_2_3_cub_97.5")) %>%
  mutate(type = ifelse(name == "mean_p_2_3_cub", "mean", "credible_interval"))


ggplot(data = df.for.plot, 
       aes(x = var, y = value, linetype = type, group = name)) +
  geom_line() +
  scale_linetype_manual(limits = c("mean", "credible_interval"),
                        values = c("solid", "dotted"),
                        labels = c("Mean", "CI")) +
  theme_bw() +
  labs(x = var_full_name,
       y = "Probability of having 2-3 cubs", 
       linetype = "") 





# B. Model with only ice-free days (Bernouilli =================================

CR_data <- read_csv("06_processed_data/CR_data/CR_f_with_cubs_clean.csv")

# Sea ice data
sea_ice_data <- read_csv("06_processed_data/sea_ice_data/retreat_advance_ice_free_days_D.csv")
sea_ice_data <- data.frame(sea_ice_data,
                           ice_free_days_previous = c(NA, sea_ice_data$ice_free_days[-nrow(sea_ice_data)]),
                           ice_free_days_2y_prior = c(NA, NA, sea_ice_data$ice_free_days[-c(nrow(sea_ice_data),
                                                                                            nrow(sea_ice_data) - 1)]))

data_model <- CR_data %>%
  left_join(x = CR_data,
            y = sea_ice_data,
            by = "year") %>%
  mutate(outcome = ifelse(cub_number == 1, 0, 1))

y <- data_model %>%
  pull(outcome)




# Renumérotation des années
{year <- data_model$year
  year <- factor(year) # laisse tomber les modalites inutiles 
  year2 <- NULL
  for (i in 1:length(year)){
    year2 <- c(year2, which(year[i] == levels(year)))
  }
  year <- factor(year2)
  nbyear <- length(levels(year))
  year
  }


dat <- list(y = as.numeric(y))
# Load the JAGS models + the ancillary functions
source("05_script/models/functions_for_models_Nimble.R")


model_1.1.2_D_binomial <- nimbleCode({
  for(i in 1:N) {
    y[i] ~ dbin(p[i], 1)
    logit(p[i]) <- b0 + b1 * ice_free_days_previous_s[i] + eps1[year[i]]
  }
  for (i in 1:nbyear) {
    eps1[i] ~ dnorm(0, sd = sigma1)
  }
  sigma1 ~ dunif(0.00000E+00, 10)
  b0 ~ dnorm(0.00000E+00, sd = 1.5)
  b1 ~ dnorm(0.00000E+00, sd = 1.5)
})



# ~~~ a. Run the model ---------------------------------------------------------

# Predictor
var <- data_model$ice_free_days_previous
var_scaled <- scale(var)
var_short_name <- "ice_free_days_previous_s"
var_full_name <- "Ice-free days in previous year"

# Are females without cubs taken into account ?

my.constants <- list(N = length(y),            # nb of females captured
                     year = as.numeric(year),
                     nbyear = nbyear,
                     as.numeric(var_scaled)) 
names(my.constants)[4] <- var_short_name


# Define the parameters to estimate
params <- c("b0", "b1", "sigma1", "eps1")
temp.data <- data.frame(y = y, 
                        var_scaled = var_scaled)
mylogit <- glm(as.factor(y) ~ var_scaled, data = temp.data, family = "binomial")

inits <- function() list(b0 = mylogit$coefficients[1] + round(runif(n = 1, -1, 1))/10, 
                         b1 = mylogit$coefficients[2] + round(runif(n = 1, -1, 1))/10,
                         sigma1 = runif(1))



# Run the model
start <- Sys.time()

fit_1.1.2_D_binomial <- nimbleMCMC(code = model_1.1.2_D_binomial,     # model code  
                                   data = dat,                                   
                                   constants = my.constants,        
                                   inits = inits,          
                                   monitors = params,   # parameters to monitor
                                   thin = 10,
                                   niter = 20000,                  # nb iterations
                                   nburnin = 5000,              # length of the burn-in
                                   nchains = 2,
                                   summary = TRUE,
                                   WAIC = TRUE)
end <- Sys.time()
end - start


fit_1.1.2_D_binomial$WAIC

save(list = fit_1.1.2_D_binomial, 
     file = "07_results/model_1.1.2_D_binomial.RData")


# ~~~ b. Check convergence -----------------------------------------------------

nimble_output <- fit_1.1.2_D_binomial

# Process Nimble output into dataframe
chain1 <- data.frame(nimble_output[["samples"]][["chain1"]]) %>%
  dplyr::select(params[-length(params)]) %>%
  mutate(chain = "1",
         iteration = seq(1, dim(nimble_output[["samples"]][["chain1"]])[1], by = 1))
chain2 <- data.frame(nimble_output[["samples"]][["chain2"]]) %>%
  dplyr::select(params[-length(params)]) %>%
  mutate(chain = "2",
         iteration = seq(1, dim(nimble_output[["samples"]][["chain2"]])[1], by = 1))
chains <- rbind(chain1, chain2) 

chains_l <- pivot_longer(chains, cols = params[-length(params)], names_to = "parameter") 

param.mean <- chains_l %>%
  group_by(parameter, chain) %>%
  summarize(m = mean(value))

param.running.mean <- chains_l %>%
  arrange(parameter, iteration) %>%
  group_by(parameter, chain) %>%
  mutate(rm = cumsum(value)/iteration)

trace.plots <- ggplot(data = chains_l, 
                      aes(x = iteration, y = value, color = chain)) +
  geom_line() +
  labs(y = "trace") +
  theme(legend.position = "none") +
  facet_wrap( ~ parameter,
              scales = "free",
              ncol = 1)

density.plots <- ggplot(data = chains_l, 
                        aes(x = value, color = chain, fill = chain)) +
  geom_density(alpha = 0.25) +
  labs(x = "density") +
  theme(legend.position = "none") +
  facet_wrap( ~ parameter,
              scales = "free_y",
              ncol = 1)

running.mean.plot <- ggplot(param.running.mean, 
                            aes(x = iteration, y = rm, color = chain)) + 
  geom_line() + 
  geom_hline(aes(yintercept = m), param.mean,
             colour = "black", alpha = 0.5) + 
  ylab("running Mean") +
  facet_grid(parameter ~ chain, scales = "free")

# Plot all the plots together
diagnostic_plot <- plot_grid(trace.plots,
                             density.plots, 
                             running.mean.plot,
                             ncol = 3, nrow = 1)
diagnostic_plot


# ~~~ c. Plot ------------------------------------------------------------------

res <- rbind(fit_1.1.2_D_binomial$samples$chain1,
             fit_1.1.2_D_binomial$samples$chain2)

# Create grid of x values
range <- range(var_scaled)

lengthgrid <- 100
grid_scaled <- seq(from = range[1] - 0.1*(range[2] - range[1]), 
                   to = range[2] + 0.1*(range[2] - range[1]), 
                   length = lengthgrid)

grid <- grid_scaled * sd(var) + mean(var)

p2_3cub <- matrix(data = NA, 
                  nrow = dim(res)[1], 
                  ncol = lengthgrid)

for (i in 1:lengthgrid) {
  for (j in 1:dim(res)[1]) {
    # p2_3cub[j, i] <- plogis(res[j, 1] + res[j, 2] * grid_scaled[i])	
    p2_3cub[j, i] <- exp(res[j, 1] + res[j, 2] * grid_scaled[i])/(1 + exp(res[j, 1] + res[j, 2] * grid_scaled[i]))
  }
}

?plogis
df.for.plot <- data.frame(var = grid,
                          mean_p_2_3_cub = apply(p2_3cub, 2, mean),
                          ci_p_2_3_cub_2.5 = apply(p2_3cub, 2, quantile, probs = 0.025),
                          ci_p_2_3_cub_97.5 = apply(p2_3cub, 2, quantile, probs = 0.975)) %>%
  pivot_longer(cols = c("mean_p_2_3_cub", "ci_p_2_3_cub_2.5", "ci_p_2_3_cub_97.5")) %>%
  mutate(type = ifelse(name == "mean_p_2_3_cub", "mean", "credible_interval"))


ggplot(data = df.for.plot, 
       aes(x = var, y = value, linetype = type, group = name)) +
  geom_line() +
  scale_linetype_manual(limits = c("mean", "credible_interval"),
                        values = c("solid", "dotted"),
                        labels = c("Mean", "CI")) +
  theme_bw() +
  labs(x = var_full_name,
       y = "Probability of having 2-3 cubs", 
       linetype = "") 
